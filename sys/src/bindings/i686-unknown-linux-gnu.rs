/* automatically generated by rust-bindgen 0.69.5 */

pub const JS_NAN_BOXING: u32 = 1;
pub const JS_PROP_CONFIGURABLE: u32 = 1;
pub const JS_PROP_WRITABLE: u32 = 2;
pub const JS_PROP_ENUMERABLE: u32 = 4;
pub const JS_PROP_C_W_E: u32 = 7;
pub const JS_PROP_LENGTH: u32 = 8;
pub const JS_PROP_TMASK: u32 = 48;
pub const JS_PROP_NORMAL: u32 = 0;
pub const JS_PROP_GETSET: u32 = 16;
pub const JS_PROP_VARREF: u32 = 32;
pub const JS_PROP_AUTOINIT: u32 = 48;
pub const JS_PROP_HAS_SHIFT: u32 = 8;
pub const JS_PROP_HAS_CONFIGURABLE: u32 = 256;
pub const JS_PROP_HAS_WRITABLE: u32 = 512;
pub const JS_PROP_HAS_ENUMERABLE: u32 = 1024;
pub const JS_PROP_HAS_GET: u32 = 2048;
pub const JS_PROP_HAS_SET: u32 = 4096;
pub const JS_PROP_HAS_VALUE: u32 = 8192;
pub const JS_PROP_THROW: u32 = 16384;
pub const JS_PROP_THROW_STRICT: u32 = 32768;
pub const JS_PROP_NO_ADD: u32 = 65536;
pub const JS_PROP_NO_EXOTIC: u32 = 131072;
pub const JS_PROP_DEFINE_PROPERTY: u32 = 262144;
pub const JS_PROP_REFLECT_DEFINE_PROPERTY: u32 = 524288;
pub const JS_DEFAULT_STACK_SIZE: u32 = 1048576;
pub const JS_EVAL_TYPE_GLOBAL: u32 = 0;
pub const JS_EVAL_TYPE_MODULE: u32 = 1;
pub const JS_EVAL_TYPE_DIRECT: u32 = 2;
pub const JS_EVAL_TYPE_INDIRECT: u32 = 3;
pub const JS_EVAL_TYPE_MASK: u32 = 3;
pub const JS_EVAL_FLAG_STRICT: u32 = 8;
pub const JS_EVAL_FLAG_UNUSED: u32 = 16;
pub const JS_EVAL_FLAG_COMPILE_ONLY: u32 = 32;
pub const JS_EVAL_FLAG_BACKTRACE_BARRIER: u32 = 64;
pub const JS_EVAL_FLAG_ASYNC: u32 = 128;
pub const JS_DUMP_BYTECODE_FINAL: u32 = 1;
pub const JS_DUMP_BYTECODE_PASS2: u32 = 2;
pub const JS_DUMP_BYTECODE_PASS1: u32 = 4;
pub const JS_DUMP_BYTECODE_HEX: u32 = 16;
pub const JS_DUMP_BYTECODE_PC2LINE: u32 = 32;
pub const JS_DUMP_BYTECODE_STACK: u32 = 64;
pub const JS_DUMP_BYTECODE_STEP: u32 = 128;
pub const JS_DUMP_READ_OBJECT: u32 = 256;
pub const JS_DUMP_FREE: u32 = 512;
pub const JS_DUMP_GC: u32 = 1024;
pub const JS_DUMP_GC_FREE: u32 = 2048;
pub const JS_DUMP_MODULE_RESOLVE: u32 = 4096;
pub const JS_DUMP_PROMISE: u32 = 8192;
pub const JS_DUMP_LEAKS: u32 = 16384;
pub const JS_DUMP_ATOM_LEAKS: u32 = 32768;
pub const JS_DUMP_MEM: u32 = 65536;
pub const JS_DUMP_OBJECTS: u32 = 131072;
pub const JS_DUMP_ATOMS: u32 = 262144;
pub const JS_DUMP_SHAPES: u32 = 524288;
pub const JS_ATOM_NULL: u32 = 0;
pub const JS_CALL_FLAG_CONSTRUCTOR: u32 = 1;
pub const JS_EVAL_OPTIONS_VERSION: u32 = 1;
pub const JS_INVALID_CLASS_ID: u32 = 0;
pub const JS_GPN_STRING_MASK: u32 = 1;
pub const JS_GPN_SYMBOL_MASK: u32 = 2;
pub const JS_GPN_PRIVATE_MASK: u32 = 4;
pub const JS_GPN_ENUM_ONLY: u32 = 16;
pub const JS_GPN_SET_ENUM: u32 = 32;
pub const JS_WRITE_OBJ_BYTECODE: u32 = 1;
pub const JS_WRITE_OBJ_BSWAP: u32 = 0;
pub const JS_WRITE_OBJ_SAB: u32 = 4;
pub const JS_WRITE_OBJ_REFERENCE: u32 = 8;
pub const JS_WRITE_OBJ_STRIP_SOURCE: u32 = 16;
pub const JS_WRITE_OBJ_STRIP_DEBUG: u32 = 32;
pub const JS_READ_OBJ_BYTECODE: u32 = 1;
pub const JS_READ_OBJ_ROM_DATA: u32 = 0;
pub const JS_READ_OBJ_SAB: u32 = 4;
pub const JS_READ_OBJ_REFERENCE: u32 = 8;
pub const JS_DEF_CFUNC: u32 = 0;
pub const JS_DEF_CGETSET: u32 = 1;
pub const JS_DEF_CGETSET_MAGIC: u32 = 2;
pub const JS_DEF_PROP_STRING: u32 = 3;
pub const JS_DEF_PROP_INT32: u32 = 4;
pub const JS_DEF_PROP_INT64: u32 = 5;
pub const JS_DEF_PROP_DOUBLE: u32 = 6;
pub const JS_DEF_PROP_UNDEFINED: u32 = 7;
pub const JS_DEF_OBJECT: u32 = 8;
pub const JS_DEF_ALIAS: u32 = 9;
pub type size_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSRuntime {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSClass {
    _unused: [u8; 0],
}
pub type JSClassID = u32;
pub type JSAtom = u32;
pub const JS_TAG_FIRST: _bindgen_ty_3 = -9;
pub const JS_TAG_BIG_INT: _bindgen_ty_3 = -9;
pub const JS_TAG_SYMBOL: _bindgen_ty_3 = -8;
pub const JS_TAG_STRING: _bindgen_ty_3 = -7;
pub const JS_TAG_MODULE: _bindgen_ty_3 = -3;
pub const JS_TAG_FUNCTION_BYTECODE: _bindgen_ty_3 = -2;
pub const JS_TAG_OBJECT: _bindgen_ty_3 = -1;
pub const JS_TAG_INT: _bindgen_ty_3 = 0;
pub const JS_TAG_BOOL: _bindgen_ty_3 = 1;
pub const JS_TAG_NULL: _bindgen_ty_3 = 2;
pub const JS_TAG_UNDEFINED: _bindgen_ty_3 = 3;
pub const JS_TAG_UNINITIALIZED: _bindgen_ty_3 = 4;
pub const JS_TAG_CATCH_OFFSET: _bindgen_ty_3 = 5;
pub const JS_TAG_EXCEPTION: _bindgen_ty_3 = 6;
pub const JS_TAG_SHORT_BIG_INT: _bindgen_ty_3 = 7;
pub const JS_TAG_FLOAT64: _bindgen_ty_3 = 8;
pub type _bindgen_ty_3 = ::core::ffi::c_int;
pub type JSValue = u64;
pub type JSCFunction = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut JSContext,
        this_val: JSValue,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
    ) -> JSValue,
>;
pub type JSCFunctionMagic = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut JSContext,
        this_val: JSValue,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
        magic: ::core::ffi::c_int,
    ) -> JSValue,
>;
pub type JSCFunctionData = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut JSContext,
        this_val: JSValue,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
        magic: ::core::ffi::c_int,
        func_data: *mut JSValue,
    ) -> JSValue,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSMallocFunctions {
    pub js_calloc: ::core::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::core::ffi::c_void,
            count: size_t,
            size: size_t,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub js_malloc: ::core::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::core::ffi::c_void,
            size: size_t,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub js_free: ::core::option::Option<
        unsafe extern "C" fn(opaque: *mut ::core::ffi::c_void, ptr: *mut ::core::ffi::c_void),
    >,
    pub js_realloc: ::core::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::core::ffi::c_void,
            ptr: *mut ::core::ffi::c_void,
            size: size_t,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub js_malloc_usable_size:
        ::core::option::Option<unsafe extern "C" fn(ptr: *const ::core::ffi::c_void) -> size_t>,
}
#[test]
fn bindgen_test_layout_JSMallocFunctions() {
    const UNINIT: ::core::mem::MaybeUninit<JSMallocFunctions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSMallocFunctions>(),
        20usize,
        concat!("Size of: ", stringify!(JSMallocFunctions))
    );
    assert_eq!(
        ::core::mem::align_of::<JSMallocFunctions>(),
        4usize,
        concat!("Alignment of ", stringify!(JSMallocFunctions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).js_calloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMallocFunctions),
            "::",
            stringify!(js_calloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).js_malloc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMallocFunctions),
            "::",
            stringify!(js_malloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).js_free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMallocFunctions),
            "::",
            stringify!(js_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).js_realloc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMallocFunctions),
            "::",
            stringify!(js_realloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).js_malloc_usable_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMallocFunctions),
            "::",
            stringify!(js_malloc_usable_size)
        )
    );
}
pub type JSRuntimeFinalizer =
    ::core::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime, arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSGCObjectHeader {
    _unused: [u8; 0],
}
extern "C" {
    pub fn JS_NewRuntime() -> *mut JSRuntime;
}
extern "C" {
    pub fn JS_SetRuntimeInfo(rt: *mut JSRuntime, info: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn JS_SetMemoryLimit(rt: *mut JSRuntime, limit: size_t);
}
extern "C" {
    pub fn JS_SetDumpFlags(rt: *mut JSRuntime, flags: u64);
}
extern "C" {
    pub fn JS_GetDumpFlags(rt: *mut JSRuntime) -> u64;
}
extern "C" {
    pub fn JS_GetGCThreshold(rt: *mut JSRuntime) -> size_t;
}
extern "C" {
    pub fn JS_SetGCThreshold(rt: *mut JSRuntime, gc_threshold: size_t);
}
extern "C" {
    pub fn JS_SetMaxStackSize(rt: *mut JSRuntime, stack_size: size_t);
}
extern "C" {
    pub fn JS_UpdateStackTop(rt: *mut JSRuntime);
}
extern "C" {
    pub fn JS_NewRuntime2(
        mf: *const JSMallocFunctions,
        opaque: *mut ::core::ffi::c_void,
    ) -> *mut JSRuntime;
}
extern "C" {
    pub fn JS_FreeRuntime(rt: *mut JSRuntime);
}
extern "C" {
    pub fn JS_GetRuntimeOpaque(rt: *mut JSRuntime) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn JS_SetRuntimeOpaque(rt: *mut JSRuntime, opaque: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn JS_AddRuntimeFinalizer(
        rt: *mut JSRuntime,
        finalizer: JSRuntimeFinalizer,
        arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
pub type JS_MarkFunc =
    ::core::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime, gp: *mut JSGCObjectHeader)>;
extern "C" {
    pub fn JS_MarkValue(rt: *mut JSRuntime, val: JSValue, mark_func: JS_MarkFunc);
}
extern "C" {
    pub fn JS_RunGC(rt: *mut JSRuntime);
}
extern "C" {
    pub fn JS_IsLiveObject(rt: *mut JSRuntime, obj: JSValue) -> bool;
}
extern "C" {
    pub fn JS_NewContext(rt: *mut JSRuntime) -> *mut JSContext;
}
extern "C" {
    pub fn JS_FreeContext(s: *mut JSContext);
}
extern "C" {
    pub fn JS_DupContext(ctx: *mut JSContext) -> *mut JSContext;
}
extern "C" {
    pub fn JS_GetContextOpaque(ctx: *mut JSContext) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn JS_SetContextOpaque(ctx: *mut JSContext, opaque: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn JS_GetRuntime(ctx: *mut JSContext) -> *mut JSRuntime;
}
extern "C" {
    pub fn JS_SetClassProto(ctx: *mut JSContext, class_id: JSClassID, obj: JSValue);
}
extern "C" {
    pub fn JS_GetClassProto(ctx: *mut JSContext, class_id: JSClassID) -> JSValue;
}
extern "C" {
    pub fn JS_GetFunctionProto(ctx: *mut JSContext) -> JSValue;
}
extern "C" {
    pub fn JS_NewContextRaw(rt: *mut JSRuntime) -> *mut JSContext;
}
extern "C" {
    pub fn JS_AddIntrinsicBaseObjects(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddIntrinsicDate(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddIntrinsicEval(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddIntrinsicRegExpCompiler(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddIntrinsicRegExp(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddIntrinsicJSON(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddIntrinsicProxy(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddIntrinsicMapSet(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddIntrinsicTypedArrays(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddIntrinsicPromise(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddIntrinsicBigInt(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddIntrinsicWeakRef(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_AddPerformance(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_IsEqual(ctx: *mut JSContext, op1: JSValue, op2: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_IsStrictEqual(ctx: *mut JSContext, op1: JSValue, op2: JSValue) -> bool;
}
extern "C" {
    pub fn JS_IsSameValue(ctx: *mut JSContext, op1: JSValue, op2: JSValue) -> bool;
}
extern "C" {
    pub fn JS_IsSameValueZero(ctx: *mut JSContext, op1: JSValue, op2: JSValue) -> bool;
}
extern "C" {
    pub fn js_string_codePointRange(
        ctx: *mut JSContext,
        this_val: JSValue,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
    ) -> JSValue;
}
extern "C" {
    pub fn js_calloc_rt(
        rt: *mut JSRuntime,
        count: size_t,
        size: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn js_malloc_rt(rt: *mut JSRuntime, size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn js_free_rt(rt: *mut JSRuntime, ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn js_realloc_rt(
        rt: *mut JSRuntime,
        ptr: *mut ::core::ffi::c_void,
        size: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn js_malloc_usable_size_rt(rt: *mut JSRuntime, ptr: *const ::core::ffi::c_void) -> size_t;
}
extern "C" {
    pub fn js_mallocz_rt(rt: *mut JSRuntime, size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn js_calloc(ctx: *mut JSContext, count: size_t, size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn js_malloc(ctx: *mut JSContext, size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn js_free(ctx: *mut JSContext, ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn js_realloc(
        ctx: *mut JSContext,
        ptr: *mut ::core::ffi::c_void,
        size: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn js_malloc_usable_size(ctx: *mut JSContext, ptr: *const ::core::ffi::c_void) -> size_t;
}
extern "C" {
    pub fn js_realloc2(
        ctx: *mut JSContext,
        ptr: *mut ::core::ffi::c_void,
        size: size_t,
        pslack: *mut size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn js_mallocz(ctx: *mut JSContext, size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn js_strdup(
        ctx: *mut JSContext,
        str_: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn js_strndup(
        ctx: *mut JSContext,
        s: *const ::core::ffi::c_char,
        n: size_t,
    ) -> *mut ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSMemoryUsage {
    pub malloc_size: i64,
    pub malloc_limit: i64,
    pub memory_used_size: i64,
    pub malloc_count: i64,
    pub memory_used_count: i64,
    pub atom_count: i64,
    pub atom_size: i64,
    pub str_count: i64,
    pub str_size: i64,
    pub obj_count: i64,
    pub obj_size: i64,
    pub prop_count: i64,
    pub prop_size: i64,
    pub shape_count: i64,
    pub shape_size: i64,
    pub js_func_count: i64,
    pub js_func_size: i64,
    pub js_func_code_size: i64,
    pub js_func_pc2line_count: i64,
    pub js_func_pc2line_size: i64,
    pub c_func_count: i64,
    pub array_count: i64,
    pub fast_array_count: i64,
    pub fast_array_elements: i64,
    pub binary_object_count: i64,
    pub binary_object_size: i64,
}
#[test]
fn bindgen_test_layout_JSMemoryUsage() {
    const UNINIT: ::core::mem::MaybeUninit<JSMemoryUsage> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSMemoryUsage>(),
        208usize,
        concat!("Size of: ", stringify!(JSMemoryUsage))
    );
    assert_eq!(
        ::core::mem::align_of::<JSMemoryUsage>(),
        4usize,
        concat!("Alignment of ", stringify!(JSMemoryUsage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).malloc_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(malloc_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).malloc_limit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(malloc_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory_used_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(memory_used_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).malloc_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(malloc_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory_used_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(memory_used_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atom_count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(atom_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atom_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(atom_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(str_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(str_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).obj_count) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(obj_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).obj_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(obj_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prop_count) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(prop_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prop_size) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(prop_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shape_count) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(shape_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shape_size) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(shape_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).js_func_count) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(js_func_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).js_func_size) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(js_func_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).js_func_code_size) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(js_func_code_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).js_func_pc2line_count) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(js_func_pc2line_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).js_func_pc2line_size) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(js_func_pc2line_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c_func_count) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(c_func_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array_count) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(array_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fast_array_count) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(fast_array_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fast_array_elements) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(fast_array_elements)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).binary_object_count) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(binary_object_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).binary_object_size) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(JSMemoryUsage),
            "::",
            stringify!(binary_object_size)
        )
    );
}
extern "C" {
    pub fn JS_ComputeMemoryUsage(rt: *mut JSRuntime, s: *mut JSMemoryUsage);
}
extern "C" {
    pub fn JS_NewAtomLen(
        ctx: *mut JSContext,
        str_: *const ::core::ffi::c_char,
        len: size_t,
    ) -> JSAtom;
}
extern "C" {
    pub fn JS_NewAtom(ctx: *mut JSContext, str_: *const ::core::ffi::c_char) -> JSAtom;
}
extern "C" {
    pub fn JS_NewAtomUInt32(ctx: *mut JSContext, n: u32) -> JSAtom;
}
extern "C" {
    pub fn JS_DupAtom(ctx: *mut JSContext, v: JSAtom) -> JSAtom;
}
extern "C" {
    pub fn JS_FreeAtom(ctx: *mut JSContext, v: JSAtom);
}
extern "C" {
    pub fn JS_FreeAtomRT(rt: *mut JSRuntime, v: JSAtom);
}
extern "C" {
    pub fn JS_AtomToValue(ctx: *mut JSContext, atom: JSAtom) -> JSValue;
}
extern "C" {
    pub fn JS_AtomToString(ctx: *mut JSContext, atom: JSAtom) -> JSValue;
}
extern "C" {
    pub fn JS_AtomToCStringLen(
        ctx: *mut JSContext,
        plen: *mut size_t,
        atom: JSAtom,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn JS_ValueToAtom(ctx: *mut JSContext, val: JSValue) -> JSAtom;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSPropertyEnum {
    pub is_enumerable: bool,
    pub atom: JSAtom,
}
#[test]
fn bindgen_test_layout_JSPropertyEnum() {
    const UNINIT: ::core::mem::MaybeUninit<JSPropertyEnum> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSPropertyEnum>(),
        8usize,
        concat!("Size of: ", stringify!(JSPropertyEnum))
    );
    assert_eq!(
        ::core::mem::align_of::<JSPropertyEnum>(),
        4usize,
        concat!("Alignment of ", stringify!(JSPropertyEnum))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_enumerable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSPropertyEnum),
            "::",
            stringify!(is_enumerable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atom) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSPropertyEnum),
            "::",
            stringify!(atom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSPropertyDescriptor {
    pub flags: ::core::ffi::c_int,
    pub value: JSValue,
    pub getter: JSValue,
    pub setter: JSValue,
}
#[test]
fn bindgen_test_layout_JSPropertyDescriptor() {
    const UNINIT: ::core::mem::MaybeUninit<JSPropertyDescriptor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSPropertyDescriptor>(),
        28usize,
        concat!("Size of: ", stringify!(JSPropertyDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<JSPropertyDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(JSPropertyDescriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSPropertyDescriptor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSPropertyDescriptor),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JSPropertyDescriptor),
            "::",
            stringify!(getter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setter) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JSPropertyDescriptor),
            "::",
            stringify!(setter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSClassExoticMethods {
    pub get_own_property: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut JSContext,
            desc: *mut JSPropertyDescriptor,
            obj: JSValue,
            prop: JSAtom,
        ) -> ::core::ffi::c_int,
    >,
    pub get_own_property_names: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut JSContext,
            ptab: *mut *mut JSPropertyEnum,
            plen: *mut u32,
            obj: JSValue,
        ) -> ::core::ffi::c_int,
    >,
    pub delete_property: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut JSContext, obj: JSValue, prop: JSAtom) -> ::core::ffi::c_int,
    >,
    pub define_own_property: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut JSContext,
            this_obj: JSValue,
            prop: JSAtom,
            val: JSValue,
            getter: JSValue,
            setter: JSValue,
            flags: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub has_property: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut JSContext, obj: JSValue, atom: JSAtom) -> ::core::ffi::c_int,
    >,
    pub get_property: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut JSContext,
            obj: JSValue,
            atom: JSAtom,
            receiver: JSValue,
        ) -> JSValue,
    >,
    pub set_property: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut JSContext,
            obj: JSValue,
            atom: JSAtom,
            value: JSValue,
            receiver: JSValue,
            flags: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout_JSClassExoticMethods() {
    const UNINIT: ::core::mem::MaybeUninit<JSClassExoticMethods> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSClassExoticMethods>(),
        28usize,
        concat!("Size of: ", stringify!(JSClassExoticMethods))
    );
    assert_eq!(
        ::core::mem::align_of::<JSClassExoticMethods>(),
        4usize,
        concat!("Alignment of ", stringify!(JSClassExoticMethods))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_own_property) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassExoticMethods),
            "::",
            stringify!(get_own_property)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_own_property_names) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassExoticMethods),
            "::",
            stringify!(get_own_property_names)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delete_property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassExoticMethods),
            "::",
            stringify!(delete_property)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).define_own_property) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassExoticMethods),
            "::",
            stringify!(define_own_property)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_property) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassExoticMethods),
            "::",
            stringify!(has_property)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_property) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassExoticMethods),
            "::",
            stringify!(get_property)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_property) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassExoticMethods),
            "::",
            stringify!(set_property)
        )
    );
}
pub type JSClassFinalizer =
    ::core::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime, val: JSValue)>;
pub type JSClassGCMark = ::core::option::Option<
    unsafe extern "C" fn(rt: *mut JSRuntime, val: JSValue, mark_func: JS_MarkFunc),
>;
pub type JSClassCall = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut JSContext,
        func_obj: JSValue,
        this_val: JSValue,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
        flags: ::core::ffi::c_int,
    ) -> JSValue,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSClassDef {
    pub class_name: *const ::core::ffi::c_char,
    pub finalizer: JSClassFinalizer,
    pub gc_mark: JSClassGCMark,
    pub call: JSClassCall,
    pub exotic: *mut JSClassExoticMethods,
}
#[test]
fn bindgen_test_layout_JSClassDef() {
    const UNINIT: ::core::mem::MaybeUninit<JSClassDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSClassDef>(),
        20usize,
        concat!("Size of: ", stringify!(JSClassDef))
    );
    assert_eq!(
        ::core::mem::align_of::<JSClassDef>(),
        4usize,
        concat!("Alignment of ", stringify!(JSClassDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDef),
            "::",
            stringify!(class_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).finalizer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDef),
            "::",
            stringify!(finalizer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gc_mark) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDef),
            "::",
            stringify!(gc_mark)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).call) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDef),
            "::",
            stringify!(call)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exotic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDef),
            "::",
            stringify!(exotic)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSEvalOptions {
    pub version: ::core::ffi::c_int,
    pub eval_flags: ::core::ffi::c_int,
    pub filename: *const ::core::ffi::c_char,
    pub line_num: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_JSEvalOptions() {
    const UNINIT: ::core::mem::MaybeUninit<JSEvalOptions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSEvalOptions>(),
        16usize,
        concat!("Size of: ", stringify!(JSEvalOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<JSEvalOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(JSEvalOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSEvalOptions),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eval_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSEvalOptions),
            "::",
            stringify!(eval_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JSEvalOptions),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line_num) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JSEvalOptions),
            "::",
            stringify!(line_num)
        )
    );
}
extern "C" {
    pub fn JS_NewClassID(rt: *mut JSRuntime, pclass_id: *mut JSClassID) -> JSClassID;
}
extern "C" {
    pub fn JS_GetClassID(v: JSValue) -> JSClassID;
}
extern "C" {
    pub fn JS_NewClass(
        rt: *mut JSRuntime,
        class_id: JSClassID,
        class_def: *const JSClassDef,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_IsRegisteredClass(rt: *mut JSRuntime, class_id: JSClassID) -> bool;
}
extern "C" {
    pub fn JS_NewNumber(ctx: *mut JSContext, d: f64) -> JSValue;
}
extern "C" {
    pub fn JS_NewBigInt64(ctx: *mut JSContext, v: i64) -> JSValue;
}
extern "C" {
    pub fn JS_NewBigUint64(ctx: *mut JSContext, v: u64) -> JSValue;
}
extern "C" {
    pub fn JS_Throw(ctx: *mut JSContext, obj: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_GetException(ctx: *mut JSContext) -> JSValue;
}
extern "C" {
    pub fn JS_HasException(ctx: *mut JSContext) -> bool;
}
extern "C" {
    pub fn JS_IsError(ctx: *mut JSContext, val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_IsUncatchableError(ctx: *mut JSContext, val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_SetUncatchableError(ctx: *mut JSContext, val: JSValue);
}
extern "C" {
    pub fn JS_ClearUncatchableError(ctx: *mut JSContext, val: JSValue);
}
extern "C" {
    pub fn JS_ResetUncatchableError(ctx: *mut JSContext);
}
extern "C" {
    pub fn JS_NewError(ctx: *mut JSContext) -> JSValue;
}
extern "C" {
    pub fn JS_ThrowPlainError(ctx: *mut JSContext, fmt: *const ::core::ffi::c_char, ...)
        -> JSValue;
}
extern "C" {
    pub fn JS_ThrowSyntaxError(
        ctx: *mut JSContext,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> JSValue;
}
extern "C" {
    pub fn JS_ThrowTypeError(ctx: *mut JSContext, fmt: *const ::core::ffi::c_char, ...) -> JSValue;
}
extern "C" {
    pub fn JS_ThrowReferenceError(
        ctx: *mut JSContext,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> JSValue;
}
extern "C" {
    pub fn JS_ThrowRangeError(ctx: *mut JSContext, fmt: *const ::core::ffi::c_char, ...)
        -> JSValue;
}
extern "C" {
    pub fn JS_ThrowInternalError(
        ctx: *mut JSContext,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> JSValue;
}
extern "C" {
    pub fn JS_ThrowOutOfMemory(ctx: *mut JSContext) -> JSValue;
}
extern "C" {
    pub fn JS_FreeValue(ctx: *mut JSContext, v: JSValue);
}
extern "C" {
    pub fn JS_FreeValueRT(rt: *mut JSRuntime, v: JSValue);
}
extern "C" {
    pub fn JS_DupValue(ctx: *mut JSContext, v: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_DupValueRT(rt: *mut JSRuntime, v: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_ToBool(ctx: *mut JSContext, val: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_ToNumber(ctx: *mut JSContext, val: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_ToInt32(ctx: *mut JSContext, pres: *mut i32, val: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_ToInt64(ctx: *mut JSContext, pres: *mut i64, val: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_ToIndex(ctx: *mut JSContext, plen: *mut u64, val: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_ToFloat64(ctx: *mut JSContext, pres: *mut f64, val: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_ToBigInt64(ctx: *mut JSContext, pres: *mut i64, val: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_ToBigUint64(ctx: *mut JSContext, pres: *mut u64, val: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_ToInt64Ext(ctx: *mut JSContext, pres: *mut i64, val: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_NewStringLen(
        ctx: *mut JSContext,
        str1: *const ::core::ffi::c_char,
        len1: size_t,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_NewTwoByteString(ctx: *mut JSContext, buf: *const u16, len: size_t) -> JSValue;
}
extern "C" {
    pub fn JS_NewAtomString(ctx: *mut JSContext, str_: *const ::core::ffi::c_char) -> JSValue;
}
extern "C" {
    pub fn JS_ToString(ctx: *mut JSContext, val: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_ToPropertyKey(ctx: *mut JSContext, val: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_ToCStringLen2(
        ctx: *mut JSContext,
        plen: *mut size_t,
        val1: JSValue,
        cesu8: bool,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn JS_FreeCString(ctx: *mut JSContext, ptr: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn JS_NewObjectProtoClass(
        ctx: *mut JSContext,
        proto: JSValue,
        class_id: JSClassID,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_NewObjectClass(ctx: *mut JSContext, class_id: ::core::ffi::c_int) -> JSValue;
}
extern "C" {
    pub fn JS_NewObjectProto(ctx: *mut JSContext, proto: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_NewObject(ctx: *mut JSContext) -> JSValue;
}
extern "C" {
    pub fn JS_NewObjectFrom(
        ctx: *mut JSContext,
        count: ::core::ffi::c_int,
        props: *const JSAtom,
        values: *const JSValue,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_NewObjectFromStr(
        ctx: *mut JSContext,
        count: ::core::ffi::c_int,
        props: *mut *const ::core::ffi::c_char,
        values: *const JSValue,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_ToObject(ctx: *mut JSContext, val: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_ToObjectString(ctx: *mut JSContext, val: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_IsFunction(ctx: *mut JSContext, val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_IsConstructor(ctx: *mut JSContext, val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_SetConstructorBit(ctx: *mut JSContext, func_obj: JSValue, val: bool) -> bool;
}
extern "C" {
    pub fn JS_IsRegExp(val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_IsMap(val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_IsSet(val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_IsWeakRef(val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_IsWeakSet(val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_IsWeakMap(val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_IsDataView(val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_NewArray(ctx: *mut JSContext) -> JSValue;
}
extern "C" {
    pub fn JS_NewArrayFrom(
        ctx: *mut JSContext,
        count: ::core::ffi::c_int,
        values: *const JSValue,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_IsArray(val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_IsProxy(val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_GetProxyTarget(ctx: *mut JSContext, proxy: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_GetProxyHandler(ctx: *mut JSContext, proxy: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_NewDate(ctx: *mut JSContext, epoch_ms: f64) -> JSValue;
}
extern "C" {
    pub fn JS_IsDate(v: JSValue) -> bool;
}
extern "C" {
    pub fn JS_GetProperty(ctx: *mut JSContext, this_obj: JSValue, prop: JSAtom) -> JSValue;
}
extern "C" {
    pub fn JS_GetPropertyUint32(ctx: *mut JSContext, this_obj: JSValue, idx: u32) -> JSValue;
}
extern "C" {
    pub fn JS_GetPropertyInt64(ctx: *mut JSContext, this_obj: JSValue, idx: i64) -> JSValue;
}
extern "C" {
    pub fn JS_GetPropertyStr(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: *const ::core::ffi::c_char,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_SetProperty(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: JSAtom,
        val: JSValue,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_SetPropertyUint32(
        ctx: *mut JSContext,
        this_obj: JSValue,
        idx: u32,
        val: JSValue,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_SetPropertyInt64(
        ctx: *mut JSContext,
        this_obj: JSValue,
        idx: i64,
        val: JSValue,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_SetPropertyStr(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: *const ::core::ffi::c_char,
        val: JSValue,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_HasProperty(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: JSAtom,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_IsExtensible(ctx: *mut JSContext, obj: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_PreventExtensions(ctx: *mut JSContext, obj: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_DeleteProperty(
        ctx: *mut JSContext,
        obj: JSValue,
        prop: JSAtom,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_SetPrototype(
        ctx: *mut JSContext,
        obj: JSValue,
        proto_val: JSValue,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_GetPrototype(ctx: *mut JSContext, val: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_GetLength(ctx: *mut JSContext, obj: JSValue, pres: *mut i64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_SetLength(ctx: *mut JSContext, obj: JSValue, len: i64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_SealObject(ctx: *mut JSContext, obj: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_FreezeObject(ctx: *mut JSContext, obj: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_GetOwnPropertyNames(
        ctx: *mut JSContext,
        ptab: *mut *mut JSPropertyEnum,
        plen: *mut u32,
        obj: JSValue,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_GetOwnProperty(
        ctx: *mut JSContext,
        desc: *mut JSPropertyDescriptor,
        obj: JSValue,
        prop: JSAtom,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_FreePropertyEnum(ctx: *mut JSContext, tab: *mut JSPropertyEnum, len: u32);
}
extern "C" {
    pub fn JS_Call(
        ctx: *mut JSContext,
        func_obj: JSValue,
        this_obj: JSValue,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_Invoke(
        ctx: *mut JSContext,
        this_val: JSValue,
        atom: JSAtom,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_CallConstructor(
        ctx: *mut JSContext,
        func_obj: JSValue,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_CallConstructor2(
        ctx: *mut JSContext,
        func_obj: JSValue,
        new_target: JSValue,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_DetectModule(input: *const ::core::ffi::c_char, input_len: size_t) -> bool;
}
extern "C" {
    pub fn JS_Eval(
        ctx: *mut JSContext,
        input: *const ::core::ffi::c_char,
        input_len: size_t,
        filename: *const ::core::ffi::c_char,
        eval_flags: ::core::ffi::c_int,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_Eval2(
        ctx: *mut JSContext,
        input: *const ::core::ffi::c_char,
        input_len: size_t,
        options: *mut JSEvalOptions,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_EvalThis(
        ctx: *mut JSContext,
        this_obj: JSValue,
        input: *const ::core::ffi::c_char,
        input_len: size_t,
        filename: *const ::core::ffi::c_char,
        eval_flags: ::core::ffi::c_int,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_EvalThis2(
        ctx: *mut JSContext,
        this_obj: JSValue,
        input: *const ::core::ffi::c_char,
        input_len: size_t,
        options: *mut JSEvalOptions,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_GetGlobalObject(ctx: *mut JSContext) -> JSValue;
}
extern "C" {
    pub fn JS_IsInstanceOf(ctx: *mut JSContext, val: JSValue, obj: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_DefineProperty(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: JSAtom,
        val: JSValue,
        getter: JSValue,
        setter: JSValue,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_DefinePropertyValue(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: JSAtom,
        val: JSValue,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_DefinePropertyValueUint32(
        ctx: *mut JSContext,
        this_obj: JSValue,
        idx: u32,
        val: JSValue,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_DefinePropertyValueStr(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: *const ::core::ffi::c_char,
        val: JSValue,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_DefinePropertyGetSet(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: JSAtom,
        getter: JSValue,
        setter: JSValue,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_SetOpaque(obj: JSValue, opaque: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_GetOpaque(obj: JSValue, class_id: JSClassID) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn JS_GetOpaque2(
        ctx: *mut JSContext,
        obj: JSValue,
        class_id: JSClassID,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn JS_GetAnyOpaque(obj: JSValue, class_id: *mut JSClassID) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn JS_ParseJSON(
        ctx: *mut JSContext,
        buf: *const ::core::ffi::c_char,
        buf_len: size_t,
        filename: *const ::core::ffi::c_char,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_JSONStringify(
        ctx: *mut JSContext,
        obj: JSValue,
        replacer: JSValue,
        space0: JSValue,
    ) -> JSValue;
}
pub type JSFreeArrayBufferDataFunc = ::core::option::Option<
    unsafe extern "C" fn(
        rt: *mut JSRuntime,
        opaque: *mut ::core::ffi::c_void,
        ptr: *mut ::core::ffi::c_void,
    ),
>;
extern "C" {
    pub fn JS_NewArrayBuffer(
        ctx: *mut JSContext,
        buf: *mut u8,
        len: size_t,
        free_func: JSFreeArrayBufferDataFunc,
        opaque: *mut ::core::ffi::c_void,
        is_shared: bool,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_NewArrayBufferCopy(ctx: *mut JSContext, buf: *const u8, len: size_t) -> JSValue;
}
extern "C" {
    pub fn JS_DetachArrayBuffer(ctx: *mut JSContext, obj: JSValue);
}
extern "C" {
    pub fn JS_GetArrayBuffer(ctx: *mut JSContext, psize: *mut size_t, obj: JSValue) -> *mut u8;
}
extern "C" {
    pub fn JS_IsArrayBuffer(obj: JSValue) -> bool;
}
extern "C" {
    pub fn JS_GetUint8Array(ctx: *mut JSContext, psize: *mut size_t, obj: JSValue) -> *mut u8;
}
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_UINT8C: JSTypedArrayEnum = 0;
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_INT8: JSTypedArrayEnum = 1;
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_UINT8: JSTypedArrayEnum = 2;
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_INT16: JSTypedArrayEnum = 3;
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_UINT16: JSTypedArrayEnum = 4;
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_INT32: JSTypedArrayEnum = 5;
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_UINT32: JSTypedArrayEnum = 6;
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_BIG_INT64: JSTypedArrayEnum = 7;
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_BIG_UINT64: JSTypedArrayEnum = 8;
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_FLOAT16: JSTypedArrayEnum = 9;
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_FLOAT32: JSTypedArrayEnum = 10;
pub const JSTypedArrayEnum_JS_TYPED_ARRAY_FLOAT64: JSTypedArrayEnum = 11;
pub type JSTypedArrayEnum = ::core::ffi::c_uint;
extern "C" {
    pub fn JS_NewTypedArray(
        ctx: *mut JSContext,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
        array_type: JSTypedArrayEnum,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_GetTypedArrayBuffer(
        ctx: *mut JSContext,
        obj: JSValue,
        pbyte_offset: *mut size_t,
        pbyte_length: *mut size_t,
        pbytes_per_element: *mut size_t,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_NewUint8Array(
        ctx: *mut JSContext,
        buf: *mut u8,
        len: size_t,
        free_func: JSFreeArrayBufferDataFunc,
        opaque: *mut ::core::ffi::c_void,
        is_shared: bool,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_GetTypedArrayType(obj: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_NewUint8ArrayCopy(ctx: *mut JSContext, buf: *const u8, len: size_t) -> JSValue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSSharedArrayBufferFunctions {
    pub sab_alloc: ::core::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::core::ffi::c_void,
            size: size_t,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub sab_free: ::core::option::Option<
        unsafe extern "C" fn(opaque: *mut ::core::ffi::c_void, ptr: *mut ::core::ffi::c_void),
    >,
    pub sab_dup: ::core::option::Option<
        unsafe extern "C" fn(opaque: *mut ::core::ffi::c_void, ptr: *mut ::core::ffi::c_void),
    >,
    pub sab_opaque: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_JSSharedArrayBufferFunctions() {
    const UNINIT: ::core::mem::MaybeUninit<JSSharedArrayBufferFunctions> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSSharedArrayBufferFunctions>(),
        16usize,
        concat!("Size of: ", stringify!(JSSharedArrayBufferFunctions))
    );
    assert_eq!(
        ::core::mem::align_of::<JSSharedArrayBufferFunctions>(),
        4usize,
        concat!("Alignment of ", stringify!(JSSharedArrayBufferFunctions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sab_alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSSharedArrayBufferFunctions),
            "::",
            stringify!(sab_alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sab_free) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSSharedArrayBufferFunctions),
            "::",
            stringify!(sab_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sab_dup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JSSharedArrayBufferFunctions),
            "::",
            stringify!(sab_dup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sab_opaque) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JSSharedArrayBufferFunctions),
            "::",
            stringify!(sab_opaque)
        )
    );
}
extern "C" {
    pub fn JS_SetSharedArrayBufferFunctions(
        rt: *mut JSRuntime,
        sf: *const JSSharedArrayBufferFunctions,
    );
}
pub const JSPromiseStateEnum_JS_PROMISE_PENDING: JSPromiseStateEnum = 0;
pub const JSPromiseStateEnum_JS_PROMISE_FULFILLED: JSPromiseStateEnum = 1;
pub const JSPromiseStateEnum_JS_PROMISE_REJECTED: JSPromiseStateEnum = 2;
pub type JSPromiseStateEnum = ::core::ffi::c_uint;
extern "C" {
    pub fn JS_NewPromiseCapability(ctx: *mut JSContext, resolving_funcs: *mut JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_PromiseState(ctx: *mut JSContext, promise: JSValue) -> JSPromiseStateEnum;
}
extern "C" {
    pub fn JS_PromiseResult(ctx: *mut JSContext, promise: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_IsPromise(val: JSValue) -> bool;
}
extern "C" {
    pub fn JS_NewSymbol(
        ctx: *mut JSContext,
        description: *const ::core::ffi::c_char,
        is_global: bool,
    ) -> JSValue;
}
pub const JSPromiseHookType_JS_PROMISE_HOOK_INIT: JSPromiseHookType = 0;
pub const JSPromiseHookType_JS_PROMISE_HOOK_BEFORE: JSPromiseHookType = 1;
pub const JSPromiseHookType_JS_PROMISE_HOOK_AFTER: JSPromiseHookType = 2;
pub const JSPromiseHookType_JS_PROMISE_HOOK_RESOLVE: JSPromiseHookType = 3;
pub type JSPromiseHookType = ::core::ffi::c_uint;
pub type JSPromiseHook = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut JSContext,
        type_: JSPromiseHookType,
        promise: JSValue,
        parent_promise: JSValue,
        opaque: *mut ::core::ffi::c_void,
    ),
>;
extern "C" {
    pub fn JS_SetPromiseHook(
        rt: *mut JSRuntime,
        promise_hook: JSPromiseHook,
        opaque: *mut ::core::ffi::c_void,
    );
}
pub type JSHostPromiseRejectionTracker = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut JSContext,
        promise: JSValue,
        reason: JSValue,
        is_handled: bool,
        opaque: *mut ::core::ffi::c_void,
    ),
>;
extern "C" {
    pub fn JS_SetHostPromiseRejectionTracker(
        rt: *mut JSRuntime,
        cb: JSHostPromiseRejectionTracker,
        opaque: *mut ::core::ffi::c_void,
    );
}
pub type JSInterruptHandler = ::core::option::Option<
    unsafe extern "C" fn(
        rt: *mut JSRuntime,
        opaque: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    pub fn JS_SetInterruptHandler(
        rt: *mut JSRuntime,
        cb: JSInterruptHandler,
        opaque: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn JS_SetCanBlock(rt: *mut JSRuntime, can_block: bool);
}
extern "C" {
    pub fn JS_SetIsHTMLDDA(ctx: *mut JSContext, obj: JSValue);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSModuleDef {
    _unused: [u8; 0],
}
pub type JSModuleNormalizeFunc = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut JSContext,
        module_base_name: *const ::core::ffi::c_char,
        module_name: *const ::core::ffi::c_char,
        opaque: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_char,
>;
pub type JSModuleLoaderFunc = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut JSContext,
        module_name: *const ::core::ffi::c_char,
        opaque: *mut ::core::ffi::c_void,
    ) -> *mut JSModuleDef,
>;
extern "C" {
    pub fn JS_SetModuleLoaderFunc(
        rt: *mut JSRuntime,
        module_normalize: JSModuleNormalizeFunc,
        module_loader: JSModuleLoaderFunc,
        opaque: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn JS_GetImportMeta(ctx: *mut JSContext, m: *mut JSModuleDef) -> JSValue;
}
extern "C" {
    pub fn JS_GetModuleName(ctx: *mut JSContext, m: *mut JSModuleDef) -> JSAtom;
}
extern "C" {
    pub fn JS_GetModuleNamespace(ctx: *mut JSContext, m: *mut JSModuleDef) -> JSValue;
}
pub type JSJobFunc = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut JSContext,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
    ) -> JSValue,
>;
extern "C" {
    pub fn JS_EnqueueJob(
        ctx: *mut JSContext,
        job_func: JSJobFunc,
        argc: ::core::ffi::c_int,
        argv: *mut JSValue,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_IsJobPending(rt: *mut JSRuntime) -> bool;
}
extern "C" {
    pub fn JS_ExecutePendingJob(
        rt: *mut JSRuntime,
        pctx: *mut *mut JSContext,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSSABTab {
    pub tab: *mut *mut u8,
    pub len: size_t,
}
#[test]
fn bindgen_test_layout_JSSABTab() {
    const UNINIT: ::core::mem::MaybeUninit<JSSABTab> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSSABTab>(),
        8usize,
        concat!("Size of: ", stringify!(JSSABTab))
    );
    assert_eq!(
        ::core::mem::align_of::<JSSABTab>(),
        4usize,
        concat!("Alignment of ", stringify!(JSSABTab))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tab) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSSABTab),
            "::",
            stringify!(tab)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSSABTab),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn JS_WriteObject(
        ctx: *mut JSContext,
        psize: *mut size_t,
        obj: JSValue,
        flags: ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn JS_WriteObject2(
        ctx: *mut JSContext,
        psize: *mut size_t,
        obj: JSValue,
        flags: ::core::ffi::c_int,
        psab_tab: *mut JSSABTab,
    ) -> *mut u8;
}
extern "C" {
    pub fn JS_ReadObject(
        ctx: *mut JSContext,
        buf: *const u8,
        buf_len: size_t,
        flags: ::core::ffi::c_int,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_ReadObject2(
        ctx: *mut JSContext,
        buf: *const u8,
        buf_len: size_t,
        flags: ::core::ffi::c_int,
        psab_tab: *mut JSSABTab,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_EvalFunction(ctx: *mut JSContext, fun_obj: JSValue) -> JSValue;
}
extern "C" {
    pub fn JS_ResolveModule(ctx: *mut JSContext, obj: JSValue) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_GetScriptOrModuleName(
        ctx: *mut JSContext,
        n_stack_levels: ::core::ffi::c_int,
    ) -> JSAtom;
}
extern "C" {
    pub fn JS_LoadModule(
        ctx: *mut JSContext,
        basename: *const ::core::ffi::c_char,
        filename: *const ::core::ffi::c_char,
    ) -> JSValue;
}
pub const JSCFunctionEnum_JS_CFUNC_generic: JSCFunctionEnum = 0;
pub const JSCFunctionEnum_JS_CFUNC_generic_magic: JSCFunctionEnum = 1;
pub const JSCFunctionEnum_JS_CFUNC_constructor: JSCFunctionEnum = 2;
pub const JSCFunctionEnum_JS_CFUNC_constructor_magic: JSCFunctionEnum = 3;
pub const JSCFunctionEnum_JS_CFUNC_constructor_or_func: JSCFunctionEnum = 4;
pub const JSCFunctionEnum_JS_CFUNC_constructor_or_func_magic: JSCFunctionEnum = 5;
pub const JSCFunctionEnum_JS_CFUNC_f_f: JSCFunctionEnum = 6;
pub const JSCFunctionEnum_JS_CFUNC_f_f_f: JSCFunctionEnum = 7;
pub const JSCFunctionEnum_JS_CFUNC_getter: JSCFunctionEnum = 8;
pub const JSCFunctionEnum_JS_CFUNC_setter: JSCFunctionEnum = 9;
pub const JSCFunctionEnum_JS_CFUNC_getter_magic: JSCFunctionEnum = 10;
pub const JSCFunctionEnum_JS_CFUNC_setter_magic: JSCFunctionEnum = 11;
pub const JSCFunctionEnum_JS_CFUNC_iterator_next: JSCFunctionEnum = 12;
pub type JSCFunctionEnum = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union JSCFunctionType {
    pub generic: JSCFunction,
    pub generic_magic: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut JSContext,
            this_val: JSValue,
            argc: ::core::ffi::c_int,
            argv: *mut JSValue,
            magic: ::core::ffi::c_int,
        ) -> JSValue,
    >,
    pub constructor: JSCFunction,
    pub constructor_magic: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut JSContext,
            new_target: JSValue,
            argc: ::core::ffi::c_int,
            argv: *mut JSValue,
            magic: ::core::ffi::c_int,
        ) -> JSValue,
    >,
    pub constructor_or_func: JSCFunction,
    pub f_f: ::core::option::Option<unsafe extern "C" fn(arg1: f64) -> f64>,
    pub f_f_f: ::core::option::Option<unsafe extern "C" fn(arg1: f64, arg2: f64) -> f64>,
    pub getter: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut JSContext, this_val: JSValue) -> JSValue,
    >,
    pub setter: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut JSContext, this_val: JSValue, val: JSValue) -> JSValue,
    >,
    pub getter_magic: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut JSContext,
            this_val: JSValue,
            magic: ::core::ffi::c_int,
        ) -> JSValue,
    >,
    pub setter_magic: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut JSContext,
            this_val: JSValue,
            val: JSValue,
            magic: ::core::ffi::c_int,
        ) -> JSValue,
    >,
    pub iterator_next: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut JSContext,
            this_val: JSValue,
            argc: ::core::ffi::c_int,
            argv: *mut JSValue,
            pdone: *mut ::core::ffi::c_int,
            magic: ::core::ffi::c_int,
        ) -> JSValue,
    >,
}
#[test]
fn bindgen_test_layout_JSCFunctionType() {
    const UNINIT: ::core::mem::MaybeUninit<JSCFunctionType> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSCFunctionType>(),
        4usize,
        concat!("Size of: ", stringify!(JSCFunctionType))
    );
    assert_eq!(
        ::core::mem::align_of::<JSCFunctionType>(),
        4usize,
        concat!("Alignment of ", stringify!(JSCFunctionType))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(generic_magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).constructor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(constructor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).constructor_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(constructor_magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).constructor_or_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(constructor_or_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(f_f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_f_f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(f_f_f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(getter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(setter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getter_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(getter_magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setter_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(setter_magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iterator_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionType),
            "::",
            stringify!(iterator_next)
        )
    );
}
extern "C" {
    pub fn JS_NewCFunction2(
        ctx: *mut JSContext,
        func: JSCFunction,
        name: *const ::core::ffi::c_char,
        length: ::core::ffi::c_int,
        cproto: JSCFunctionEnum,
        magic: ::core::ffi::c_int,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_NewCFunction3(
        ctx: *mut JSContext,
        func: JSCFunction,
        name: *const ::core::ffi::c_char,
        length: ::core::ffi::c_int,
        cproto: JSCFunctionEnum,
        magic: ::core::ffi::c_int,
        proto_val: JSValue,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_NewCFunctionData(
        ctx: *mut JSContext,
        func: JSCFunctionData,
        length: ::core::ffi::c_int,
        magic: ::core::ffi::c_int,
        data_len: ::core::ffi::c_int,
        data: *mut JSValue,
    ) -> JSValue;
}
extern "C" {
    pub fn JS_SetConstructor(ctx: *mut JSContext, func_obj: JSValue, proto: JSValue);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JSCFunctionListEntry {
    pub name: *const ::core::ffi::c_char,
    pub prop_flags: u8,
    pub def_type: u8,
    pub magic: i16,
    pub u: JSCFunctionListEntry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JSCFunctionListEntry__bindgen_ty_1 {
    pub func: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1,
    pub getset: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2,
    pub alias: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3,
    pub prop_list: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4,
    pub str_: *const ::core::ffi::c_char,
    pub i32_: i32,
    pub i64_: i64,
    pub u64_: u64,
    pub f64_: f64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1 {
    pub length: u8,
    pub cproto: u8,
    pub cfunc: JSCFunctionType,
}
#[test]
fn bindgen_test_layout_JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cproto) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(cproto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cfunc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(cfunc)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2 {
    pub get: JSCFunctionType,
    pub set: JSCFunctionType,
}
#[test]
fn bindgen_test_layout_JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(set)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3 {
    pub name: *const ::core::ffi::c_char,
    pub base: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4 {
    pub tab: *const JSCFunctionListEntry,
    pub len: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tab) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(tab)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(len)
        )
    );
}
#[test]
fn bindgen_test_layout_JSCFunctionListEntry__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<JSCFunctionListEntry__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSCFunctionListEntry__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(JSCFunctionListEntry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<JSCFunctionListEntry__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1),
            "::",
            stringify!(getset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prop_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1),
            "::",
            stringify!(prop_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry__bindgen_ty_1),
            "::",
            stringify!(f64_)
        )
    );
}
#[test]
fn bindgen_test_layout_JSCFunctionListEntry() {
    const UNINIT: ::core::mem::MaybeUninit<JSCFunctionListEntry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<JSCFunctionListEntry>(),
        16usize,
        concat!("Size of: ", stringify!(JSCFunctionListEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<JSCFunctionListEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(JSCFunctionListEntry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prop_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry),
            "::",
            stringify!(prop_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).def_type) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry),
            "::",
            stringify!(def_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JSCFunctionListEntry),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    pub fn JS_SetPropertyFunctionList(
        ctx: *mut JSContext,
        obj: JSValue,
        tab: *const JSCFunctionListEntry,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
pub type JSModuleInitFunc = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut JSContext, m: *mut JSModuleDef) -> ::core::ffi::c_int,
>;
extern "C" {
    pub fn JS_NewCModule(
        ctx: *mut JSContext,
        name_str: *const ::core::ffi::c_char,
        func: JSModuleInitFunc,
    ) -> *mut JSModuleDef;
}
extern "C" {
    pub fn JS_AddModuleExport(
        ctx: *mut JSContext,
        m: *mut JSModuleDef,
        name_str: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_AddModuleExportList(
        ctx: *mut JSContext,
        m: *mut JSModuleDef,
        tab: *const JSCFunctionListEntry,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_SetModuleExport(
        ctx: *mut JSContext,
        m: *mut JSModuleDef,
        export_name: *const ::core::ffi::c_char,
        val: JSValue,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_SetModuleExportList(
        ctx: *mut JSContext,
        m: *mut JSModuleDef,
        tab: *const JSCFunctionListEntry,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn JS_GetVersion() -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn js_std_cmd(cmd: ::core::ffi::c_int, ...) -> usize;
}
pub const __JS_ATOM_NULL: _bindgen_ty_4 = 0;
pub const JS_ATOM_null: _bindgen_ty_4 = 1;
pub const JS_ATOM_false: _bindgen_ty_4 = 2;
pub const JS_ATOM_true: _bindgen_ty_4 = 3;
pub const JS_ATOM_if: _bindgen_ty_4 = 4;
pub const JS_ATOM_else: _bindgen_ty_4 = 5;
pub const JS_ATOM_return: _bindgen_ty_4 = 6;
pub const JS_ATOM_var: _bindgen_ty_4 = 7;
pub const JS_ATOM_this: _bindgen_ty_4 = 8;
pub const JS_ATOM_delete: _bindgen_ty_4 = 9;
pub const JS_ATOM_void: _bindgen_ty_4 = 10;
pub const JS_ATOM_typeof: _bindgen_ty_4 = 11;
pub const JS_ATOM_new: _bindgen_ty_4 = 12;
pub const JS_ATOM_in: _bindgen_ty_4 = 13;
pub const JS_ATOM_instanceof: _bindgen_ty_4 = 14;
pub const JS_ATOM_do: _bindgen_ty_4 = 15;
pub const JS_ATOM_while: _bindgen_ty_4 = 16;
pub const JS_ATOM_for: _bindgen_ty_4 = 17;
pub const JS_ATOM_break: _bindgen_ty_4 = 18;
pub const JS_ATOM_continue: _bindgen_ty_4 = 19;
pub const JS_ATOM_switch: _bindgen_ty_4 = 20;
pub const JS_ATOM_case: _bindgen_ty_4 = 21;
pub const JS_ATOM_default: _bindgen_ty_4 = 22;
pub const JS_ATOM_throw: _bindgen_ty_4 = 23;
pub const JS_ATOM_try: _bindgen_ty_4 = 24;
pub const JS_ATOM_catch: _bindgen_ty_4 = 25;
pub const JS_ATOM_finally: _bindgen_ty_4 = 26;
pub const JS_ATOM_function: _bindgen_ty_4 = 27;
pub const JS_ATOM_debugger: _bindgen_ty_4 = 28;
pub const JS_ATOM_with: _bindgen_ty_4 = 29;
pub const JS_ATOM_class: _bindgen_ty_4 = 30;
pub const JS_ATOM_const: _bindgen_ty_4 = 31;
pub const JS_ATOM_enum: _bindgen_ty_4 = 32;
pub const JS_ATOM_export: _bindgen_ty_4 = 33;
pub const JS_ATOM_extends: _bindgen_ty_4 = 34;
pub const JS_ATOM_import: _bindgen_ty_4 = 35;
pub const JS_ATOM_super: _bindgen_ty_4 = 36;
pub const JS_ATOM_implements: _bindgen_ty_4 = 37;
pub const JS_ATOM_interface: _bindgen_ty_4 = 38;
pub const JS_ATOM_let: _bindgen_ty_4 = 39;
pub const JS_ATOM_package: _bindgen_ty_4 = 40;
pub const JS_ATOM_private: _bindgen_ty_4 = 41;
pub const JS_ATOM_protected: _bindgen_ty_4 = 42;
pub const JS_ATOM_public: _bindgen_ty_4 = 43;
pub const JS_ATOM_static: _bindgen_ty_4 = 44;
pub const JS_ATOM_yield: _bindgen_ty_4 = 45;
pub const JS_ATOM_await: _bindgen_ty_4 = 46;
pub const JS_ATOM_empty_string: _bindgen_ty_4 = 47;
pub const JS_ATOM_keys: _bindgen_ty_4 = 48;
pub const JS_ATOM_size: _bindgen_ty_4 = 49;
pub const JS_ATOM_length: _bindgen_ty_4 = 50;
pub const JS_ATOM_message: _bindgen_ty_4 = 51;
pub const JS_ATOM_cause: _bindgen_ty_4 = 52;
pub const JS_ATOM_errors: _bindgen_ty_4 = 53;
pub const JS_ATOM_stack: _bindgen_ty_4 = 54;
pub const JS_ATOM_name: _bindgen_ty_4 = 55;
pub const JS_ATOM_toString: _bindgen_ty_4 = 56;
pub const JS_ATOM_toLocaleString: _bindgen_ty_4 = 57;
pub const JS_ATOM_valueOf: _bindgen_ty_4 = 58;
pub const JS_ATOM_eval: _bindgen_ty_4 = 59;
pub const JS_ATOM_prototype: _bindgen_ty_4 = 60;
pub const JS_ATOM_constructor: _bindgen_ty_4 = 61;
pub const JS_ATOM_configurable: _bindgen_ty_4 = 62;
pub const JS_ATOM_writable: _bindgen_ty_4 = 63;
pub const JS_ATOM_enumerable: _bindgen_ty_4 = 64;
pub const JS_ATOM_value: _bindgen_ty_4 = 65;
pub const JS_ATOM_get: _bindgen_ty_4 = 66;
pub const JS_ATOM_set: _bindgen_ty_4 = 67;
pub const JS_ATOM_of: _bindgen_ty_4 = 68;
pub const JS_ATOM___proto__: _bindgen_ty_4 = 69;
pub const JS_ATOM_undefined: _bindgen_ty_4 = 70;
pub const JS_ATOM_number: _bindgen_ty_4 = 71;
pub const JS_ATOM_boolean: _bindgen_ty_4 = 72;
pub const JS_ATOM_string: _bindgen_ty_4 = 73;
pub const JS_ATOM_object: _bindgen_ty_4 = 74;
pub const JS_ATOM_symbol: _bindgen_ty_4 = 75;
pub const JS_ATOM_integer: _bindgen_ty_4 = 76;
pub const JS_ATOM_unknown: _bindgen_ty_4 = 77;
pub const JS_ATOM_arguments: _bindgen_ty_4 = 78;
pub const JS_ATOM_callee: _bindgen_ty_4 = 79;
pub const JS_ATOM_caller: _bindgen_ty_4 = 80;
pub const JS_ATOM__eval_: _bindgen_ty_4 = 81;
pub const JS_ATOM__ret_: _bindgen_ty_4 = 82;
pub const JS_ATOM__var_: _bindgen_ty_4 = 83;
pub const JS_ATOM__arg_var_: _bindgen_ty_4 = 84;
pub const JS_ATOM__with_: _bindgen_ty_4 = 85;
pub const JS_ATOM_lastIndex: _bindgen_ty_4 = 86;
pub const JS_ATOM_target: _bindgen_ty_4 = 87;
pub const JS_ATOM_index: _bindgen_ty_4 = 88;
pub const JS_ATOM_input: _bindgen_ty_4 = 89;
pub const JS_ATOM_defineProperties: _bindgen_ty_4 = 90;
pub const JS_ATOM_apply: _bindgen_ty_4 = 91;
pub const JS_ATOM_join: _bindgen_ty_4 = 92;
pub const JS_ATOM_concat: _bindgen_ty_4 = 93;
pub const JS_ATOM_split: _bindgen_ty_4 = 94;
pub const JS_ATOM_construct: _bindgen_ty_4 = 95;
pub const JS_ATOM_getPrototypeOf: _bindgen_ty_4 = 96;
pub const JS_ATOM_setPrototypeOf: _bindgen_ty_4 = 97;
pub const JS_ATOM_isExtensible: _bindgen_ty_4 = 98;
pub const JS_ATOM_preventExtensions: _bindgen_ty_4 = 99;
pub const JS_ATOM_has: _bindgen_ty_4 = 100;
pub const JS_ATOM_deleteProperty: _bindgen_ty_4 = 101;
pub const JS_ATOM_defineProperty: _bindgen_ty_4 = 102;
pub const JS_ATOM_getOwnPropertyDescriptor: _bindgen_ty_4 = 103;
pub const JS_ATOM_ownKeys: _bindgen_ty_4 = 104;
pub const JS_ATOM_add: _bindgen_ty_4 = 105;
pub const JS_ATOM_done: _bindgen_ty_4 = 106;
pub const JS_ATOM_next: _bindgen_ty_4 = 107;
pub const JS_ATOM_values: _bindgen_ty_4 = 108;
pub const JS_ATOM_source: _bindgen_ty_4 = 109;
pub const JS_ATOM_flags: _bindgen_ty_4 = 110;
pub const JS_ATOM_global: _bindgen_ty_4 = 111;
pub const JS_ATOM_unicode: _bindgen_ty_4 = 112;
pub const JS_ATOM_raw: _bindgen_ty_4 = 113;
pub const JS_ATOM_new_target: _bindgen_ty_4 = 114;
pub const JS_ATOM_this_active_func: _bindgen_ty_4 = 115;
pub const JS_ATOM_home_object: _bindgen_ty_4 = 116;
pub const JS_ATOM_computed_field: _bindgen_ty_4 = 117;
pub const JS_ATOM_static_computed_field: _bindgen_ty_4 = 118;
pub const JS_ATOM_class_fields_init: _bindgen_ty_4 = 119;
pub const JS_ATOM_brand: _bindgen_ty_4 = 120;
pub const JS_ATOM_hash_constructor: _bindgen_ty_4 = 121;
pub const JS_ATOM_as: _bindgen_ty_4 = 122;
pub const JS_ATOM_from: _bindgen_ty_4 = 123;
pub const JS_ATOM_fromAsync: _bindgen_ty_4 = 124;
pub const JS_ATOM_meta: _bindgen_ty_4 = 125;
pub const JS_ATOM__default_: _bindgen_ty_4 = 126;
pub const JS_ATOM__star_: _bindgen_ty_4 = 127;
pub const JS_ATOM_Module: _bindgen_ty_4 = 128;
pub const JS_ATOM_then: _bindgen_ty_4 = 129;
pub const JS_ATOM_resolve: _bindgen_ty_4 = 130;
pub const JS_ATOM_reject: _bindgen_ty_4 = 131;
pub const JS_ATOM_promise: _bindgen_ty_4 = 132;
pub const JS_ATOM_proxy: _bindgen_ty_4 = 133;
pub const JS_ATOM_revoke: _bindgen_ty_4 = 134;
pub const JS_ATOM_async: _bindgen_ty_4 = 135;
pub const JS_ATOM_exec: _bindgen_ty_4 = 136;
pub const JS_ATOM_groups: _bindgen_ty_4 = 137;
pub const JS_ATOM_indices: _bindgen_ty_4 = 138;
pub const JS_ATOM_status: _bindgen_ty_4 = 139;
pub const JS_ATOM_reason: _bindgen_ty_4 = 140;
pub const JS_ATOM_globalThis: _bindgen_ty_4 = 141;
pub const JS_ATOM_bigint: _bindgen_ty_4 = 142;
pub const JS_ATOM_not_equal: _bindgen_ty_4 = 143;
pub const JS_ATOM_timed_out: _bindgen_ty_4 = 144;
pub const JS_ATOM_ok: _bindgen_ty_4 = 145;
pub const JS_ATOM_toJSON: _bindgen_ty_4 = 146;
pub const JS_ATOM_maxByteLength: _bindgen_ty_4 = 147;
pub const JS_ATOM_Object: _bindgen_ty_4 = 148;
pub const JS_ATOM_Array: _bindgen_ty_4 = 149;
pub const JS_ATOM_Error: _bindgen_ty_4 = 150;
pub const JS_ATOM_Number: _bindgen_ty_4 = 151;
pub const JS_ATOM_String: _bindgen_ty_4 = 152;
pub const JS_ATOM_Boolean: _bindgen_ty_4 = 153;
pub const JS_ATOM_Symbol: _bindgen_ty_4 = 154;
pub const JS_ATOM_Arguments: _bindgen_ty_4 = 155;
pub const JS_ATOM_Math: _bindgen_ty_4 = 156;
pub const JS_ATOM_JSON: _bindgen_ty_4 = 157;
pub const JS_ATOM_Date: _bindgen_ty_4 = 158;
pub const JS_ATOM_Function: _bindgen_ty_4 = 159;
pub const JS_ATOM_GeneratorFunction: _bindgen_ty_4 = 160;
pub const JS_ATOM_ForInIterator: _bindgen_ty_4 = 161;
pub const JS_ATOM_RegExp: _bindgen_ty_4 = 162;
pub const JS_ATOM_ArrayBuffer: _bindgen_ty_4 = 163;
pub const JS_ATOM_SharedArrayBuffer: _bindgen_ty_4 = 164;
pub const JS_ATOM_Uint8ClampedArray: _bindgen_ty_4 = 165;
pub const JS_ATOM_Int8Array: _bindgen_ty_4 = 166;
pub const JS_ATOM_Uint8Array: _bindgen_ty_4 = 167;
pub const JS_ATOM_Int16Array: _bindgen_ty_4 = 168;
pub const JS_ATOM_Uint16Array: _bindgen_ty_4 = 169;
pub const JS_ATOM_Int32Array: _bindgen_ty_4 = 170;
pub const JS_ATOM_Uint32Array: _bindgen_ty_4 = 171;
pub const JS_ATOM_BigInt64Array: _bindgen_ty_4 = 172;
pub const JS_ATOM_BigUint64Array: _bindgen_ty_4 = 173;
pub const JS_ATOM_Float16Array: _bindgen_ty_4 = 174;
pub const JS_ATOM_Float32Array: _bindgen_ty_4 = 175;
pub const JS_ATOM_Float64Array: _bindgen_ty_4 = 176;
pub const JS_ATOM_DataView: _bindgen_ty_4 = 177;
pub const JS_ATOM_BigInt: _bindgen_ty_4 = 178;
pub const JS_ATOM_WeakRef: _bindgen_ty_4 = 179;
pub const JS_ATOM_FinalizationRegistry: _bindgen_ty_4 = 180;
pub const JS_ATOM_Map: _bindgen_ty_4 = 181;
pub const JS_ATOM_Set: _bindgen_ty_4 = 182;
pub const JS_ATOM_WeakMap: _bindgen_ty_4 = 183;
pub const JS_ATOM_WeakSet: _bindgen_ty_4 = 184;
pub const JS_ATOM_Iterator: _bindgen_ty_4 = 185;
pub const JS_ATOM_IteratorHelper: _bindgen_ty_4 = 186;
pub const JS_ATOM_IteratorWrap: _bindgen_ty_4 = 187;
pub const JS_ATOM_Map_Iterator: _bindgen_ty_4 = 188;
pub const JS_ATOM_Set_Iterator: _bindgen_ty_4 = 189;
pub const JS_ATOM_Array_Iterator: _bindgen_ty_4 = 190;
pub const JS_ATOM_String_Iterator: _bindgen_ty_4 = 191;
pub const JS_ATOM_RegExp_String_Iterator: _bindgen_ty_4 = 192;
pub const JS_ATOM_Generator: _bindgen_ty_4 = 193;
pub const JS_ATOM_Proxy: _bindgen_ty_4 = 194;
pub const JS_ATOM_Promise: _bindgen_ty_4 = 195;
pub const JS_ATOM_PromiseResolveFunction: _bindgen_ty_4 = 196;
pub const JS_ATOM_PromiseRejectFunction: _bindgen_ty_4 = 197;
pub const JS_ATOM_AsyncFunction: _bindgen_ty_4 = 198;
pub const JS_ATOM_AsyncFunctionResolve: _bindgen_ty_4 = 199;
pub const JS_ATOM_AsyncFunctionReject: _bindgen_ty_4 = 200;
pub const JS_ATOM_AsyncGeneratorFunction: _bindgen_ty_4 = 201;
pub const JS_ATOM_AsyncGenerator: _bindgen_ty_4 = 202;
pub const JS_ATOM_EvalError: _bindgen_ty_4 = 203;
pub const JS_ATOM_RangeError: _bindgen_ty_4 = 204;
pub const JS_ATOM_ReferenceError: _bindgen_ty_4 = 205;
pub const JS_ATOM_SyntaxError: _bindgen_ty_4 = 206;
pub const JS_ATOM_TypeError: _bindgen_ty_4 = 207;
pub const JS_ATOM_URIError: _bindgen_ty_4 = 208;
pub const JS_ATOM_InternalError: _bindgen_ty_4 = 209;
pub const JS_ATOM_CallSite: _bindgen_ty_4 = 210;
pub const JS_ATOM_Private_brand: _bindgen_ty_4 = 211;
pub const JS_ATOM_Symbol_toPrimitive: _bindgen_ty_4 = 212;
pub const JS_ATOM_Symbol_iterator: _bindgen_ty_4 = 213;
pub const JS_ATOM_Symbol_match: _bindgen_ty_4 = 214;
pub const JS_ATOM_Symbol_matchAll: _bindgen_ty_4 = 215;
pub const JS_ATOM_Symbol_replace: _bindgen_ty_4 = 216;
pub const JS_ATOM_Symbol_search: _bindgen_ty_4 = 217;
pub const JS_ATOM_Symbol_split: _bindgen_ty_4 = 218;
pub const JS_ATOM_Symbol_toStringTag: _bindgen_ty_4 = 219;
pub const JS_ATOM_Symbol_isConcatSpreadable: _bindgen_ty_4 = 220;
pub const JS_ATOM_Symbol_hasInstance: _bindgen_ty_4 = 221;
pub const JS_ATOM_Symbol_species: _bindgen_ty_4 = 222;
pub const JS_ATOM_Symbol_unscopables: _bindgen_ty_4 = 223;
pub const JS_ATOM_Symbol_asyncIterator: _bindgen_ty_4 = 224;
pub const JS_ATOM_END: _bindgen_ty_4 = 225;
pub type _bindgen_ty_4 = ::core::ffi::c_uint;
